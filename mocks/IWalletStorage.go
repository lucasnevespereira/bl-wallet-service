// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	storage "bl-wallet-service/internal/storage"

	mock "github.com/stretchr/testify/mock"
)

// IWalletStorage is an autogenerated mock type for the IWalletStorage type
type IWalletStorage struct {
	mock.Mock
}

// AutoMigrate provides a mock function with given fields:
func (_m *IWalletStorage) AutoMigrate() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTransaction provides a mock function with given fields: transaction
func (_m *IWalletStorage) CreateTransaction(transaction *storage.RowTransaction) error {
	ret := _m.Called(transaction)

	var r0 error
	if rf, ok := ret.Get(0).(func(*storage.RowTransaction) error); ok {
		r0 = rf(transaction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateWallet provides a mock function with given fields: wallet
func (_m *IWalletStorage) CreateWallet(wallet *storage.RowWallet) error {
	ret := _m.Called(wallet)

	var r0 error
	if rf, ok := ret.Get(0).(func(*storage.RowWallet) error); ok {
		r0 = rf(wallet)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetTransaction provides a mock function with given fields: transactionID
func (_m *IWalletStorage) GetTransaction(transactionID string) (*storage.RowTransaction, error) {
	ret := _m.Called(transactionID)

	var r0 *storage.RowTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*storage.RowTransaction, error)); ok {
		return rf(transactionID)
	}
	if rf, ok := ret.Get(0).(func(string) *storage.RowTransaction); ok {
		r0 = rf(transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.RowTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletByUserID provides a mock function with given fields: userID
func (_m *IWalletStorage) GetWalletByUserID(userID string) (*storage.RowWallet, error) {
	ret := _m.Called(userID)

	var r0 *storage.RowWallet
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*storage.RowWallet, error)); ok {
		return rf(userID)
	}
	if rf, ok := ret.Get(0).(func(string) *storage.RowWallet); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.RowWallet)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBalance provides a mock function with given fields: wallet, transactionID
func (_m *IWalletStorage) UpdateBalance(wallet *storage.RowWallet, transactionID string) error {
	ret := _m.Called(wallet, transactionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(*storage.RowWallet, string) error); ok {
		r0 = rf(wallet, transactionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewIWalletStorage creates a new instance of IWalletStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIWalletStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *IWalletStorage {
	mock := &IWalletStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
